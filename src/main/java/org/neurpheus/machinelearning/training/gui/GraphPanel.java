/*
 * Neurpheus - Machine Learning Package
 *
 * Copyright (C) 2009, 2016 Jakub Strychowski
 *
 *  This library is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as published by the Free
 *  Software Foundation; either version 3.0 of the License, or (at your option)
 *  any later version.
 *
 *  This library is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 *  for more details.
 */

package org.neurpheus.machinelearning.training.gui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

/**
 *
 * @author  jstrychowski
 */
public class GraphPanel extends javax.swing.JPanel implements Serializable {
    
    
    static final long serialVersionUID = 7706080711121904L;
    
    /** Creates new form GraphPanel */
    public GraphPanel() {
        initComponents();
        forcedMinX = - Double.MAX_VALUE;
        forcedMinY = - Double.MAX_VALUE;
        forcedMaxX = - Double.MAX_VALUE;
        forcedMaxY = - Double.MAX_VALUE;
        graphColor = new Color(0, 0, 128);
        axisColor = new Color(0, 0, 0);
        gridColor = Color.LIGHT_GRAY;
        leftMargin = 10;
        rightMargin = 10;
        topMargin = 10;
        bottomMargin = 10;
        showAxisX = true;
        showAxisY = true;
        showGrid = true;
        gridDensityX = 10;
        gridDensityY = 10;
        
    }
    
    private List points;
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    public List getPoints() {
        return points;
    }

    public void setPoints(List points) {
        this.points = points;
        minMaxValuesDetermined = false;
        repaint();
    }

    private Color graphColor;
    private Color axisColor;
    private Color gridColor;
    private boolean showGrid;
    private boolean showAxisX;
    private boolean showAxisY;
    private int leftMargin, rightMargin, topMargin, bottomMargin;
    private int gridDensityX;
    private int gridDensityY;
    
    
    private double forcedMinX, forcedMinY, forcedMaxX, forcedMaxY;
    private double minX, maxX, minY, maxY;
    private double xFactor, yFactor, xShift, yShift;
    private boolean minMaxValuesDetermined = false;
    private int axisPosition = 6;
    private int arrowSize = 3;

    protected void determineMinMaxValues() {
        minX = Double.MAX_VALUE;
        maxX = - Double.MAX_VALUE;
        minY = minX;
        maxY = maxX;
        for (final Iterator it = points.iterator(); it.hasNext();) {
            double[] point = (double[]) it.next();
            if (point[0] < minX) {
                minX = point[0];
            } 
            if (forcedMinX != - Double.MAX_VALUE) {
                minX = forcedMinX;
            }
            if (point[0] > maxX) {
                maxX = point[0];
            }
            if (forcedMaxX != - Double.MAX_VALUE) {
                maxX = forcedMaxX;
            }
            if (point[1] < minY) {
                minY = point[1];
            }
            if (forcedMinY != - Double.MAX_VALUE) {
                minY = forcedMinY;
            }
            if (point[1] > maxY) {
                maxY = point[1];
            }
            if (forcedMaxY != - Double.MAX_VALUE) {
                maxY = forcedMaxY;
            }
        }
        xShift = leftMargin;
        yShift = bottomMargin;
        
        minMaxValuesDetermined = true;
    }
    
    public void paint(Graphics g) {
        super.paint(g);
        if (points != null) {
            
            if (!minMaxValuesDetermined) {
                determineMinMaxValues();
            }
            
            xFactor = maxX == minX ? 1 : (getWidth() - leftMargin - rightMargin) / (maxX - minX);
            yFactor = maxY == minY ? 1 : (getHeight() - topMargin - bottomMargin) / (maxY - minY);

            if (showGrid) {
                g.setColor(gridColor);
                Font oldFont = g.getFont();
                g.setFont(oldFont.deriveFont(6));
                double stepX = (maxX - minX) / gridDensityX;
                for (double x = minX; x <= maxX; x+= stepX) {
                    int x0 = (int) Math.round((x -minX) * xFactor + xShift);
                    g.drawLine(x0, axisPosition, x0, getHeight() - axisPosition);
                    g.drawString(Double.toString(x), x0, getHeight() - axisPosition + arrowSize);
                }
                double stepY = (maxY - minY) / gridDensityY;
                for (double y = minY; y <= maxY; y+= stepY) {
                    int y0 = getHeight() - (int) Math.round((y - minY) * yFactor + yShift);
                    g.drawLine(axisPosition, y0, getWidth() - axisPosition, y0);
                    g.drawString(Double.toString(y), axisPosition - arrowSize, y0);
                }
                g.setFont(oldFont);
            }
            
            if (showAxisY) {
                g.setColor(axisColor);
                int x0 = (int) Math.round(-minX * xFactor + xShift);
                if (x0 >= 0 && x0 < getWidth()) {
                    // paint y axis
                    g.drawLine(x0, axisPosition, x0, getHeight() - axisPosition);
                    g.drawLine(x0, axisPosition, x0 - arrowSize, axisPosition + arrowSize);
                    g.drawLine(x0, axisPosition, x0 + arrowSize, axisPosition + arrowSize);
                }
            }
            if (showAxisX) {
                g.setColor(axisColor);
                int y0 = getHeight() - (int) Math.round(-minY * yFactor + yShift);
                if (y0 >= 0 && y0 < getHeight()) {
                    // paint x axis
                    g.drawLine(axisPosition, y0, getWidth() - axisPosition, y0);
                    g.drawLine(getWidth() - axisPosition, y0, getWidth() - axisPosition - arrowSize, y0 - arrowSize);
                    g.drawLine(getWidth() - axisPosition, y0, getWidth() - axisPosition - arrowSize, y0 + arrowSize);
                }
            }
            
            // paint graph curve
            g.setColor(getGraphColor());
            final Iterator it = points.iterator();
            if (it.hasNext()) {
                double[] startPoint = (double[]) it.next();
                while (it.hasNext()) {
                    double[] point = (double[]) it.next();
                    int x1 = (int) Math.round((startPoint[0] -minX) * xFactor + xShift);
                    int y1 = getHeight() - (int) Math.round((startPoint[1] -minY) * yFactor + yShift);
                    int x2 = (int) Math.round((point[0] - minX) * xFactor + xShift);
                    int y2 = getHeight() - (int) Math.round((point[1] - minY) * yFactor + yShift);
                    g.drawLine(x1, y1, x2, y2);
                    startPoint = point;
                }
            }
            
        }
    }

    protected double getMinX() {
        return minX;
    }

    protected void setMinX(double minX) {
        this.minX = minX;
    }

    protected double getMaxX() {
        return maxX;
    }

    protected void setMaxX(double maxX) {
        this.maxX = maxX;
    }

    protected double getMinY() {
        return minY;
    }

    protected void setMinY(double minY) {
        this.minY = minY;
    }

    protected double getMaxY() {
        return maxY;
    }

    protected void setMaxY(double maxY) {
        this.maxY = maxY;
    }

    protected double getXFactor() {
        return xFactor;
    }

    protected void setXFactor(double xFactor) {
        this.xFactor = xFactor;
    }

    protected double getYFactor() {
        return yFactor;
    }

    protected void setYFactor(double yFactor) {
        this.yFactor = yFactor;
    }

    protected double getXShift() {
        return xShift;
    }

    protected void setXShift(double xShift) {
        this.xShift = xShift;
    }

    protected double getYShift() {
        return yShift;
    }

    protected void setYShift(double yShift) {
        this.yShift = yShift;
    }

    protected boolean isMinMaxValuesDetermined() {
        return minMaxValuesDetermined;
    }

    protected void setMinMaxValuesDetermined(boolean minMaxValuesDetermined) {
        this.minMaxValuesDetermined = minMaxValuesDetermined;
    }

    public double getForcedMinX() {
        return forcedMinX;
    }

    public void setForcedMinX(double forcedMinX) {
        this.forcedMinX = forcedMinX;
    }

    public double getForcedMinY() {
        return forcedMinY;
    }

    public void setForcedMinY(double forcedMinY) {
        this.forcedMinY = forcedMinY;
    }

    public double getForcedMaxX() {
        return forcedMaxX;
    }

    public void setForcedMaxX(double forcedMaxX) {
        this.forcedMaxX = forcedMaxX;
    }

    public double getForcedMaxY() {
        return forcedMaxY;
    }

    public void setForcedMaxY(double forcedMaxY) {
        this.forcedMaxY = forcedMaxY;
    }

    public Color getGraphColor() {
        return graphColor;
    }

    public void setGraphColor(Color graphColor) {
        this.graphColor = graphColor;
    }
    
    
    
    
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
}
